<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Otsu Thresholding</title>
  <link rel="stylesheet" href="../style.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</head>
<body>
  <div class="container">
    <!-- Sidebar -->
    <nav class="sidebar">
      <h2>Thresholding</h2>
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="threshold.html">Thresholding</a></li>
        <li><a href="double_thresholding.html">Double Thresholding</a></li>
        <li><a href="otsu_thresholding.html" class="active">Otsu Method</a></li>
        <li><a href="adaptive_thresholding.html">Adaptive Thresholding</a></li>
      </ul>
    </nav>

    <!-- Main Content -->
    <main class="content">
      <h1>Otsu Thresholding</h1>

      <!-- Theory Section -->
      <section>
        <h2>Theory</h2>
        <p>
          <strong>Otsu’s method</strong> is an automatic global thresholding technique that selects the optimal threshold by maximizing the separation between two classes of pixels (foreground and background). 
          It is widely used in image segmentation, especially for bimodal histograms.
        </p>
        <ul>
          <li><b>Global Thresholding:</b> A fixed threshold is applied across the entire image. Simple but may fail if image lighting varies.</li>
          <li><b>Otsu’s Thresholding:</b> Automatically computes the threshold by minimizing the intra-class variance (variance within foreground and background pixels).</li>
          <li><b>Gaussian Pre-filtering + Otsu:</b> Applying a Gaussian blur before Otsu thresholding reduces noise, giving a cleaner separation of object and background.</li>
          <li><b>Applications:</b> Document scanning, medical imaging, object detection, and preprocessing for morphological operations.</li>
        </ul>
        <p>
          The key advantage of Otsu’s method is that it adapts to the image’s histogram automatically, removing the need for manual threshold selection.
        </p>
      </section>

      <!-- Python Code Section -->
      <section>
        <h2>Python Code</h2>
        <pre><code class="language-python">
import cv2 as cv
import numpy as np
from matplotlib import pyplot as plt

# Load grayscale image
img = cv.imread('assets/noisy3.png', cv.IMREAD_GRAYSCALE)
assert img is not None, "file could not be read"

# Global thresholding
ret1, th1 = cv.threshold(img, 127, 255, cv.THRESH_BINARY)

# Otsu's thresholding
ret2, th2 = cv.threshold(img, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU)

# Otsu's thresholding after Gaussian filtering
blur = cv.GaussianBlur(img, (5,5), 0)
ret3, th3 = cv.threshold(blur, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU)

# Plot results
images = [img, 0, th1,
          img, 0, th2,
          blur, 0, th3]
titles = ['Original Noisy Image','Histogram','Global Thresholding (v=127)',
          'Original Noisy Image','Histogram',"Otsu's Thresholding",
          'Gaussian Filtered Image','Histogram',"Otsu's Thresholding"]

for i in range(3):
    plt.subplot(3, 3, i*3+1), plt.imshow(images[i*3], 'gray')
    plt.title(titles[i*3]), plt.xticks([]), plt.yticks([])
    plt.subplot(3, 3, i*3+2), plt.hist(images[i*3].ravel(), 256)
    plt.title(titles[i*3+1]), plt.xticks([]), plt.yticks([])
    plt.subplot(3, 3, i*3+3), plt.imshow(images[i*3+2], 'gray')
    plt.title(titles[i*3+2]), plt.xticks([]), plt.yticks([])

plt.tight_layout()
plt.show()
        </code></pre>
      </section>

      <!-- Output Section -->
      <section>
        <h2>Output</h2>
        <img src="../assets/otsu.png" alt="Otsu Thresholding Example" width="800">
      </section>
    </main>
  </div>
   <script>
document.addEventListener('DOMContentLoaded', () => {
  const toggleBtn = document.createElement('div');
  toggleBtn.className = 'menu-toggle';
  toggleBtn.innerText = '☰ Menu';
  document.body.appendChild(toggleBtn);

  const sidebar = document.querySelector('.sidebar');
  toggleBtn.addEventListener('click', () => {
    toggleBtn.style.display = 'none';
    sidebar.classList.toggle('active');
  });
});
</script>
</body>
</html>
